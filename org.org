#+TITLE: Hackathon TechXplosion
#+AUTHOR: Team TechXplosion
#+STARTUP: overview
#+TODO: TODO IN-PROGRESS | DONE SCRAPPED

* Idea
** Problem
Public buildings and student housing waste energy on heating, lighting, and ventilation for empty rooms. Decisions are made without insight into actual usage patterns. Sensors can collect real-time data (temperature, occupancy, air quality, power consumption), but the challenge is turning this data into actionable information for users (staff, students, residents) without feeling intrusive or confusing.

*Task*: Build a system that shows where energy is wasted, suggests actions, or auto-adjusts settings—while remaining user-friendly and non-invasive.

** Solution
*FlowMetrics*
Heatmap system showing where and how the different metrics behave over time,
visualizing and emphasise where and how the metrics are worse. Maybe create a
suggestion system.

Automatically adjust metrics;
*** Example:
Someone left a window open in a room
*Symptoms:*
- Heating requires more power compared to usual (outside, historical, others)
- Air quality rises naturally (hopefully)
*Action:*
- Reduce power to heating, start listening to temperature. If starting to rise
  again -> normal power (window closed)
- Reduce ventilation if air quality seems good, window takes care of the rest.

*** How it looks:

**** Dashboard:


**** Map:

A heatmap inspired visualization for the different metrics. Used to analyze
where losses happen, and how the whole system (building) works in unison

Floor 3:
|---+-----+-----|
|   |     | 18C |
|---+-----+-----|
|   | 18C |     |
|---+-----+-----|
|   | 18C |     |
|---+-----+-----|

Floor 2:
|---+---+---|
|   |   |   |
|---+---+---|
|   |   |   |
|---+---+---|
|   |   |   |
|---+---+---|

Floor 1:
|---+---+---|
|   |   |   |
|---+---+---|
|   |   |   |
|---+---+---|
|   |   |   |
|---+---+---|

** Why it matters
Increases:
- Observability
- Prioritization

Decreases:
- Cost
- Environmental stuff


* Tech Stack
- Python 3.14
  - [[https://fastapi.tiangolo.com/][FastAPI]]
- Web
  - Deck.gl [[https://github.com/visgl/deck.gl/tree/9.2-release/examples/website/screen-grid][Grid]]
  - Vite
  - React
- Tooling: uv, ruff, basedpyright



* Architecture
** Feature Spec
- [ ] Plantegning - Med etasjer
- [ ] Overvåking av metrics, og basere det på lokasjon
- [ ] Kunne plassere IoT og andre ting, og dette skal jobbe automatisk
- [ ] Hvor lekker "metrics"? Altså, lekker ett rom varme ut av bygget/inn til et
  annet rom?
- [ ] Bruke soldata (vinkel, styrke, etc.. ) i kalkuleringer [[https://www.sunearthtools.com/dp/tools/pos_sun.php?lang=en][SunEarthTools]]
** Overview

*** Data Flow Diagram

#+begin_example
  ┌─────────────────────-┐
  │    IoT Sensors       │
  │ (temp, occupancy,    │
  │  co2, power, light)  │
  └─────────┬────────────┘
            │ raw readings
            ▼
  ┌──────────────────────────────────────────────────┐
  │              Backend (FastAPI)                   │
  │                                                  │
  │  Sensors → Room → Floor → Building            │
  │  (collect)  (detect waste)  (aggregate)          │
  │                                                  │
  │  Serves two things:                              │
  │                                                  │
  │  1. GET /building                                │
  │     → BuildingLayout (geometry in meters)       │
  │     → fetched once on page load                 │
  │					             │
  │  2. WS /ws                                       │
  │     → MetricsUpdate (live sensor values)        │
  │     → pushed every tick                         │
  └─────┬──────────────────────────┬─────────────────┘
        │                          │
        │ BuildingLayout           │ MetricsUpdate
        │ (once)                   │ (continuous)
        ▼                          ▼
  ┌──────────────────────────────────────────────────┐
  │           Frontend (React + Canvas)              │
  │                                                  │
  │  1. GET /building → store geometry              │
  │  2. WS /ws → receive metrics each tick          │
  │  3. Merge metrics onto geometry by room id       │
  │  4. Scale meter coords to canvas pixels          │
  │  5. Draw rooms, color by selected metric         │
  │                                                  │
  │  All filtering (floor, metric) is client-side.   │
  │  Backend does not know what the user looks at.   │
  └──────────────────────────────────────────────────┘
#+end_example

*** Contract: Coordinate System

All spatial values are in *meters*. Origin =(0, 0)= is the top-left corner
of the building footprint. X increases rightward, Y increases downward.

Rooms are closed polygons defined by a list of =[x, y]= coordinate pairs in
meters. The last point connects back to the first implicitly. A simple
rectangle is just four points: =[[0,0], [10,0], [10,9], [0,9]]=.

The frontend scales meter coordinates to canvas pixels using:
=pixel = meter * (canvas_size / building_size_m)=

*** Contract: =GET /building= → BuildingLayout

Fetched once on page load. Defines the physical structure.

#+begin_src json
{
  "id": "building-1",
  "name": "Student Housing A",
  "width_m": 30.0,
  "height_m": 18.0,
  "floors": [
    {
      "floor_index": 0,
      "label": "Floor 1",
      "rooms": [
        {
          "id": "r-101",
          "name": "Lobby",
          "polygon": [[0,0], [10,0], [10,9], [0,9]]
        },
        {
          "id": "r-102",
          "name": "Room 102",
          "polygon": [[10,0], [20,0], [20,9], [10,9]]
        },
        {
          "id": "r-103",
          "name": "Kitchen",
          "polygon": [[0,9], [15,9], [15,18], [0,18]]
        }
      ]
    },
    {
      "floor_index": 1,
      "label": "Floor 2",
      "rooms": [
        {
          "id": "r-201",
          "name": "Room 201",
          "polygon": [[0,0], [15,0], [15,9], [0,9]]
        },
        {
          "id": "r-202",
          "name": "Room 202",
          "polygon": [[15,0], [30,0], [30,9], [15,9]]
        }
      ]
    }
  ]
}
#+end_src

*** Contract: =WS /ws= → MetricsUpdate

Pushed by backend every tick. Flat map of room id → current metrics.
Frontend merges this into the stored geometry to color the rooms.

#+begin_src json
{
  "tick": 1234,
  "rooms": {
    "r-101": {
      "temperature": 22.5,
      "occupancy": 0.4,
      "co2": 450,
      "power": 200,
      "waste_patterns": []
    },
    "r-102": {
      "temperature": 26.0,
      "occupancy": 0.0,
      "co2": 380,
      "power": 180,
      "waste_patterns": ["empty_room_heating_on"]
    }
  }
}
#+end_src

*** Contract: Summary

| What              | How             | Payload                             | When              |
|-------------------+-----------------+-------------------------------------+-------------------|
| Building geometry | =GET /building= | rooms as polygons =[x,y]= in meters | once on page load |
| Live metrics      | =WS /ws=        | room id → metric values            | every tick        |

- Geometry and metrics are *separate*. The backend can change room layouts
  without touching the metrics stream, and vice versa.
- Room =id= is the join key between geometry and metrics.
- All coordinates in meters. Frontend scales to pixels.
- Backend pushes *all* rooms every tick. Frontend filters by floor client-side.

** Key Components
**** Entities:
- IoT Sensor :: Heat | Air quality | Occupancy
- Metric-improver-devices :: Power Consumption && ( Heating effect | Air quality effect and
  spreading of air )
** Polymorphic Hierarchical Approach

The same core logic -- collect metrics, identify waste, act, visualize --
applies at every level of the building hierarchy. Start at the smallest unit
(room), compose upward (floor, building). Each level produces concrete metrics
about *where* energy is wasted and *what* to do about it.

*** Room Level -- Detect and Act

The atomic unit. Sensors measure temperature, occupancy, power draw, and
lighting. The system identifies concrete waste patterns and acts automatically:

- *Open window + heating on* -- temperature dropping while radiator runs.
  Action: lower heating setpoint until window closes.
- *Empty room + lights/heating on* -- occupancy reads zero for 30+ min.
  Action: turn off lights, reduce heating to standby.
- *Appliances on standby overnight* -- power draw with nobody present.
  Action: cut power to smart plugs on a schedule.
- *Over-heating* -- room at 24C when setpoint is 21C (stuck valve, sun
  exposure). Action: flag anomaly, reduce heating.
- *Ventilation at full in empty space* -- HVAC working with no occupants.
  Action: reduce to minimum airflow.

Each waste pattern produces a metric: estimated kWh wasted, duration, cause.
These are the building blocks for everything above.

*** Device Mesh -- Local Communication Between Sensors

IoT devices in proximity form a mesh network and talk directly to each other.
Instead of routing everything through a central server, neighboring devices
share state and react based on a local rule engine:

- *Heat propagation* -- a temperature sensor in room 301 detects a spike. The
  sensor in adjacent room 302 notices and preemptively lowers its own heating
  before the heat reaches it, avoiding overshoot.
- *Occupancy ripple* -- someone leaves room 301 and the hallway motion sensor
  picks them up. The devices in 301 know to start winding down, while the
  common room devices prepare for possible arrival.
- *Window-open chain* -- a temperature drop detected near an exterior wall
  propagates to neighboring thermostats: "don't compensate by cranking up
  heat, the cause is an open window nearby."

The rules are simple and local: if your neighbor reports X, do Y. This keeps
latency low (devices react in seconds, not waiting for a round-trip to a
server), works even if the network connection drops, and scales naturally --
adding a new device just means it joins the mesh and starts talking to its
neighbors. The central system still collects the data for aggregation and
visualization, but the *actions* happen at the edge.

*** Floor Level -- Aggregate, Compare, Engage

Composes room metrics into a floor-wide view. This is where data becomes
visible to residents:

- *Rank rooms by waste* -- identifies the biggest improvement areas on the
  floor.
- *Floor-wide patterns* -- "south-facing rooms consistently overheat in the
  afternoon" reveals structural vs. behavioral issues.
- *Visualization for residents* -- ambient display in common areas shows the
  floor's energy state without singling anyone out.
- *Nudges* -- actionable and specific: "Common kitchen window open for 20 min
  while heating runs -- closing it saves ~2 kWh/hour."
- *Floor vs. floor comparison* -- gamification on reduction percentage from
  each floor's own baseline, keeping it fair.

*** Building Level -- Prioritize, Operate, Report

Composes floor metrics into a building-wide operator view:

- *Rank floors by waste* -- driftspersonell see at a glance which floor needs
  attention and why.
- *Building-wide patterns* -- "west wing uses 30% more heating than east wing"
  points to insulation or systematic valve problems.
- *Prioritized action list* -- sorted by impact. "Fixing the stuck valve on
  floor 2 saves more than all behavioral nudges on floor 4 combined."
- *Cumulative savings tracking* -- total kWh saved, cost avoided, CO2 reduced.
- *Operator dashboard* -- one-click actions to override settings, flag
  maintenance, or adjust building-wide schedules.

*** How This Addresses the Task

| Task requirement                        | How the system solves it                                    |
|-----------------------------------------+-------------------------------------------------------------|
| Show where energy is wasted             | Room-level metrics identify concrete waste (open windows,   |
|                                         | empty rooms with heating on) -- aggregated up per level     |
| Suggest concrete actions                | Each waste pattern has a specific fix attached              |
| Automatically adjust settings           | Room-level automation acts without human intervention       |
| Not feel surveillance-like              | Individual room data only used for automation, never shown  |
|                                         | publicly. Residents see floor-level aggregates only         |
| Not feel annoying or hard to understand | Nudges are specific and infrequent. Visualization is        |
|                                         | ambient. Metrics use tangible equivalents                   |
| Engage users                            | Floor-level gamification for residents. Operator dashboard  |
|                                         | for driftspersonell                                         |
| Use sensors and IoT data                | Temperature, occupancy, power, lighting sensors at room     |
|                                         | level feed everything                                       |
* Advanced Analysis
** Thermal Physics Modeling
*** Heat Transfer Network
- Model the building as a thermal graph: rooms are nodes, walls/windows are edges with conductance values
- Calculate heat flow rate: =Q = U × A × ΔT= (U-value × area × temperature difference)
- Identify "heat sinks" (rooms bleeding heat outside) vs "heat bridges" (rooms gaining unwanted heat from neighbors)
- Visualize heat flow arrows on the floor plan showing direction and magnitude

*** Thermal Mass Inference
- Track how quickly each room responds to heating/cooling
- Rooms with low thermal mass (high response rate) need different control strategies than high-mass rooms
- Detect anomalies: "Room 204 is heating 3x faster than similar rooms → possible sensor issue or open door"

*** Building Envelope Analysis
- Using interior temps + exterior temp + known wall positions, calculate effective R-values per wall section
- Flag degraded insulation: "North wall of Room 102 losing 40% more heat than expected"

** Solar Gain Integration
*** Predictive Solar Loading
- Combine sun azimuth/elevation + window orientation + window area + shading
- Calculate real-time solar gain in Watts per room
- Predict: "Room 106 will receive 2kW solar gain in 30 minutes → preemptively reduce heating"

*** Shadow Mapping
- Model which rooms are shaded by building geometry at different times
- Explain temperature differences: "Room 103 is 3°C warmer because it has direct sun exposure while 104 is shaded"

*** Seasonal Patterns
- Track solar contribution over months
- "South-facing rooms need 30% less heating in spring due to solar gain"

** Anomaly Detection & Diagnostics
*** Baseline Learning
- Build per-room behavioral profiles: typical temp range, occupancy patterns, power draw
- Statistical anomaly detection (z-score, isolation forest)
- "Room 108 power consumption is 2.5σ above normal for this time/occupancy"

*** Root Cause Analysis
When waste is detected, automatically correlate with possible causes:
- Temperature drop + high heating → window open (check if CO2 also dropping)
- Temperature rise + no heating + afternoon → solar gain
- High power + zero occupancy + night → appliance left on

*** Sensor Health Monitoring
- Cross-validate sensors: if room temp says 25°C but heating is max and neighbors are 18°C → sensor fault
- Detect stuck sensors (flatline), drift, or impossible readings

** Occupancy Intelligence
*** Pattern Learning
- Learn weekly schedules per room (lectures, office hours, common room usage)
- Predict occupancy 1-24 hours ahead with confidence intervals

*** Pre-conditioning
- "Room 201 has a class at 08:00 on Mondays → start heating at 07:30"
- Calculate optimal pre-heat time based on thermal mass and current temp

*** Occupancy Flow Analysis
- Track movement: when someone leaves room A, predict likely destination (corridor → common room → exit)
- Optimize corridor/stairwell heating based on traffic patterns

** Economic & Environmental Impact
*** Real-Time Cost
- Integrate spot electricity prices (Nord Pool for Norway)
- Show waste in NOK/hour, not just kWh
- "Current waste across building: 47 NOK/hour"

*** Carbon Accounting
- Convert kWh to kg CO2 using grid emission factor (varies by country, time of day)
- Norway daytime ≈ 20g CO2/kWh (hydro), Germany evening ≈ 400g CO2/kWh (coal peaking)

*** ROI Calculator
For each suggested fix, estimate:
- Implementation cost
- Annual savings
- Payback period
- 10-year NPV
- Example: "Fixing stuck valve in Room 203: Cost 2000 NOK, saves 1200 NOK/year, payback 1.7 years"

** Comparative & Trend Analysis
*** Degree-Day Normalization
- Normalize energy use by heating degree days (HDD) to compare across seasons
- "February used 20% more energy than January, but HDD-normalized it's actually 5% better"

*** Peer Benchmarking
- Group similar rooms (same size, orientation, floor)
- Rank within peer group: "Room 204 uses 35% more energy than similar rooms"
- Investigate outliers

*** Trend Detection
- Week-over-week, month-over-month comparisons
- Detect gradual degradation: "Room 105 heating efficiency declining 2% per month → schedule maintenance"

** Comfort Optimization
*** PMV/PPD Comfort Model
- Calculate Predicted Mean Vote (thermal comfort index) from temp, humidity, air velocity, clothing, activity
- Optimize for comfort, not just temperature
- "Room 201 is 21°C but feels cold due to draft → address air leakage instead of raising temp"

*** CO2-Based Ventilation
- Instead of fixed ventilation rates, modulate based on actual CO2 levels
- "Room 108 CO2 at 600ppm with 2 people → reduce ventilation 40% safely"

*** Multi-Objective Optimization
- Balance comfort, energy cost, and carbon
- Pareto frontier: show tradeoffs between "cheap but less comfortable" vs "comfortable but expensive"

** What-If Simulation
*** Scenario Modeling
- "What if we lowered setpoint by 1°C building-wide?" → estimate savings
- "What if we replaced windows on the north facade?" → model impact

*** Digital Twin
- Physics-based simulation of the building
- Test control strategies in simulation before deploying

* Tasks
** DONE Set up project skeleton
- [X] Setup frontend (Vite + React + TS)
- [X] Setup backend (Python + uv)
- [X] Define contract (org.org DFD + JSON schemas)
** DONE Define the core idea
** TODO Backend: Serve building layout
=GET /building= returning BuildingLayout JSON (polygons in meters).
Hardcode a sample building with 3 floors.
** TODO Backend: WebSocket metrics stream
=WS /ws= pushing MetricsUpdate every tick.
Simulated sensor data that changes over time.
** TODO Backend: Core sensor & EnergyZone system
- [X] Create sensor types (SensorKind enum, Sensor dataclass, SensorReading)
- [X] Create EnergyZone ABC with Metrics, WastePattern, Action types
- [X] Implement RoomZone (collect_metrics, identify_waste, act)
- [X] Implement FloorZone (aggregate room metrics upward)
- [X] Implement BuildingZone (aggregate floor metrics upward)
- [X] Create simulation engine (realistic sensor data with time-based drift)
- [X] Inject waste scenarios for demo (empty room heating, open window, standby appliances)
- [X] Wire WebSocket /ws endpoint with live MetricsUpdate stream
- [ ] Integration test: curl /building + wscat /ws shows live data flowing
** DONE Frontend: Canvas floor renderer
** TODO Frontend: Canvas floor renderer
Canvas component that draws room polygons colored by selected metric.
** TODO Frontend: Connect to backend
Fetch =GET /building= on load, connect =WS /ws=, merge metrics, re-render each tick.
** TODO Backend: Waste pattern detection
Room-level waste detection, included in MetricsUpdate.
** DONE Frontend: Floor selector + metric picker + hover tooltip
** TODO Integration test
Run both together, verify live data end-to-end.
** TODO Polish + demo prep

* Team
| Name  | Focus    |
|-------+----------|
| Dany  | Frontend |
| Jonas | Backend  |

* Timeline
** Friday evening
*** Dany (Frontend)
- [ ] Create TypeScript types matching the contract (BuildingLayout, MetricsUpdate)
- [ ] Build FloorGrid canvas component that takes a floor + metrics and draws polygons
- [ ] Hardcode mock BuildingLayout in frontend to test rendering without backend
- [ ] Color rooms with a basic heatmap color function (blue cold → red hot)
- [ ] Verify rooms draw correctly, walls visible, no overlaps
*** Jonas (Backend)
- [X] Add FastAPI + uvicorn + websockets to dependencies
- [X] Create Pydantic models matching the contract (BuildingLayout, MetricsUpdate)
- [X] Hardcode a sample building (3 floors, 4-6 rooms each, polygons in meters)
- [X] Implement =GET /building= endpoint returning the sample building
- [X] Test with curl / browser that the JSON looks right
** Saturday morning
*** Dany (Frontend)
- [ ] Replace mock data with =fetch("/building")= call on mount
- [ ] Connect to =WS /ws=, parse MetricsUpdate messages
- [ ] Merge incoming metrics into stored geometry, re-render canvas on each tick
- [ ] Add floor selector (tabs or buttons)
*** Jonas (Backend)
- [ ] Implement =WS /ws= endpoint, push MetricsUpdate every 2-3 seconds
- [ ] Generate simulated sensor data that drifts over time (not static)
- [ ] Add CORS config so frontend can connect from different port
- [ ] Integration check: both running, data flows end-to-end
- [X] Create sensor types and EnergyZone ABC
- [X] Implement Room/Floor/Building EnergyZone hierarchy
- [X] Build simulation engine with waste scenarios
- [X] Wire WS /ws endpoint with live metrics stream

* Demo Notes
** Pitch (30-60 sec)
** Live demo flow
** Backup plan if demo breaks

* Scratchpad
